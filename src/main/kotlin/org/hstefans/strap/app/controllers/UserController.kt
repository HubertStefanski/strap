package org.hstefans.strap.app.controllers

import org.abstractj.kalium.crypto.Hash
import org.abstractj.kalium.encoders.Encoder.HEX
import org.hstefans.strap.app.models.User
import tornadofx.Controller
import java.sql.Connection
import java.sql.ResultSet
import java.sql.SQLException
import java.sql.Statement
import java.util.*
import javax.security.sasl.AuthenticationException


class UserController : Controller() {

    companion object {
        var currentUser: User = User(null, "", "", 0)

    }

    val dbc = find(DBController::class)


    internal fun findUser(thisUsername: String): User? {
        val usrList: MutableList<User> = mutableListOf()

        var conn: Connection? = null
        var stmt: Statement? = null
        var rs: ResultSet? = null

        try {
            conn = dbc.getConnection()
            if (conn != null) {
                stmt = conn.createStatement()
            }
            stmt!!.executeQuery("SELECT * FROM USER WHERE `USERNAME` = '${thisUsername}'")
            rs = stmt.resultSet


            if (rs != null) {
                while (rs.next()) {
                    var uid =
                        UUID.fromString(rs.getString("UID")) //<- Circumvent non-assignment requirement in function
                    var phone = rs.getString("PHONE").toLong() //
                    usrList.add(User(uid, rs.getString("USERNAME"), rs.getString("PASSWORD"), phone))
                }
            }
        } catch (ex: SQLException) {
            // handle any errors
            ex.printStackTrace()
        } finally {
            // release resources
            if (rs != null) {
                try {
                    rs.close()
                } catch (sqlEx: SQLException) {
                }
            }
            if (stmt != null) {
                try {
                    stmt.close()
                } catch (sqlEx: SQLException) {
                }
            }
            if (conn != null) {
                try {
                    conn.close()
                } catch (sqlEx: SQLException) {
                }
            }
        }


        return usrList.find { user -> user.username == thisUsername }

    }

    //Authenticate user
    fun authUser(username: String, password: String): Boolean {
        val localPass = hashString(password)
        val localUser = findUser(username) ?: throw Exception("UserNotFound")
        if (localUser.password != localPass) {
            throw AuthenticationException("Could not authenticate the user")
        } else {
            currentUser = localUser
            return true
        }
    }

    //Add a new user to the json store
    fun addUser(user: User): Error? {
        if (user.username == "" || user.password == "") {
            throw IllegalArgumentException("username or password empty")
        }
        if (user.uid != null) {
            throw IllegalArgumentException("attempted to pass in an UID, UID needs to be generated by this method")
        }

        val knownUsers = getAllUsersFromDataStore()

        user.uid = UUID.randomUUID()
        //Check if uid already exists in userDB, unlikely but possible

        for (knownUser in knownUsers!!) {
            if (knownUser.username.toUpperCase() == user.username.toUpperCase()) {
                error("User with this username already exists")
//
            }
        }

        //Get hash and replace plaintext,
        user.password = hashString(user.password)
        writeToDataStore(user)
        return null
    }

    //Helper function for password hashing, more secure than plaintext
    public fun hashString(instring: String): String {

        val hash = Hash()
        val data: String = instring
        val tb = hash.sha512(data.toByteArray())
        return HEX.encode(tb)
    }


    //Return all users from datastore, used for login authentication
    private fun getAllUsersFromDataStore(): List<User>? {
        val usrList: MutableList<User> = mutableListOf()

        var conn: Connection? = null
        var stmt: Statement? = null
        var rs: ResultSet? = null

        try {
            conn = dbc.getConnection()
            if (conn != null) {
                stmt = conn.createStatement()
            }
            stmt!!.executeQuery("SELECT * FROM USER")
            rs = stmt.resultSet


            if (rs != null) {
                while (rs.next()) {
                    var uid =
                        UUID.fromString(rs.getString("UID")) //<- Circumvent non-assignment requirement in function
                    var phone = rs.getString("PHONE").toLong() //
                    usrList.add(User(uid, rs.getString("USERNAME"), rs.getString("PASSWORD"), phone))
                }
            }
        } catch (ex: SQLException) {
            // handle any errors
            ex.printStackTrace()
        } finally {
            // release resources
            if (rs != null) {
                try {
                    rs.close()
                } catch (sqlEx: SQLException) {
                }
            }
            if (stmt != null) {
                try {
                    stmt.close()
                } catch (sqlEx: SQLException) {
                }
            }
            if (conn != null) {
                try {
                    conn.close()
                } catch (sqlEx: SQLException) {
                }
            }
        }

        return usrList
    }


    private fun writeToDataStore(user: User) {
        var conn: Connection? = null
        var stmt: Statement? = null

        try {
            conn = dbc.getConnection()
            if (conn != null) {
                stmt = conn.createStatement()
            }
            stmt!!.executeUpdate("INSERT INTO USER (UID,USERNAME,PASSWORD,PHONE) VALUES('${user.uid}','${user.username}','${user.password}','${user.phone}')")


        } catch (ex: SQLException) {
            // handle any errors
            ex.printStackTrace()
        } finally {

            if (stmt != null) {
                try {
                    stmt.close()
                } catch (sqlEx: SQLException) {
                }
            }
            if (conn != null) {
                try {
                    conn.close()
                } catch (sqlEx: SQLException) {
                }
            }
        }
    }

    fun deleteUser(user: User) {
        var conn: Connection? = null
        var stmt: Statement? = null

        try {
            conn = dbc.getConnection()
            if (conn != null) {
                stmt = conn.createStatement()
            }
            stmt!!.executeUpdate("DELETE FROM `USER` WHERE `USER`.`UID`='${user.uid}'")


        } catch (ex: SQLException) {
            // handle any errors
            ex.printStackTrace()
        } finally {

            if (stmt != null) {
                try {
                    stmt.close()
                } catch (sqlEx: SQLException) {
                }
            }
            if (conn != null) {
                try {
                    conn.close()
                } catch (sqlEx: SQLException) {
                }
            }
        }
    }
}